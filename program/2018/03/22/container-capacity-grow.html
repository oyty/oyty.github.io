<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=yes"/>
    <link href="https://oyty.me/main.css" rel="stylesheet" type="text/css">
    <link href="https://oyty.me/codehighlight.css" rel="stylesheet" type="text/css">
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link rel="shortcut icon" href="https://oyty.me/images/logo.ico">
    <title>Android性能调优之容器扩容</title>
</head>
<body>
  <div class="content">
    <h2>Android性能调优之容器扩容</h2>
<p>﻿Java和Android提供了很多容器来组织对象，比如ArrayList，HashMap等，这些容器用起来虽然方便，但是也存在一些问题，也就是它们会自动扩容。这个扩容不是简单的创建一个新的对象，而且创建一个更大的容器对象，这也就意味着要占用更大的内存空间。</p>
<p>从源码角度来看看它们是如何扩容的：
<code>public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}</code>
添加新的数据对象的时候，会先检测容量
```
private void ensureCapacityInternal(int minCapacity) {
    if (elementData == EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }</p>
<pre><code>ensureExplicitCapacity(minCapacity);
</code></pre>
<p>}
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;</p>
<pre><code>// overflow-conscious code
if (minCapacity - elementData.length &gt; 0)
    grow(minCapacity);
</code></pre>
<p>}</p>
<p><code>你可以自定义最小容量，有一个默认的最小容量</code>
private static final int DEFAULT_CAPACITY = 10;
<code>如果容量不够，就需要扩容了grow</code>
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}</p>
<p>private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}
<code>``
扩容会右移一位（也就是除以2，左移一位是乘以2，我们知道位移运算要快于除法运算），也就是容量增加到原来的1.5倍。
最后使用</code>Arrays.copyOf()`创建新的数组，然后将原来的数组拷贝到新的数组里面，而这个是很耗费性能的，所以在使用ArrayList的时候，最好能提前知道数组的容量，然后直接确定，这样就可以避免数组自动扩容带来的性能和时间消耗。</p>
<p>HashMap原理和ArrayList差不多，也是创建容量对象，自动扩容，默认容量如下：
```
/*<em>
 * The default initial capacity - MUST be a power of two.
 </em>/
static final int DEFAULT_INITIAL_CAPACITY = 4;</p>
<p>```</p>
  </div>


</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115892756-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-115892756-1');
</script>


</html>