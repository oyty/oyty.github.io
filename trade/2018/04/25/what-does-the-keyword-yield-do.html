<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=yes"/>
    <link href="https://oyty.me/main.css" rel="stylesheet" type="text/css">
    <link href="https://oyty.me/codehighlight.css" rel="stylesheet" type="text/css">
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link rel="shortcut icon" href="https://oyty.me/images/logo.ico">
    <title><code>[Scrapy-1]</code>如何理解<code>yield</code>关键字</title>
</head>
<body>
  <div class="content">
    <h2><code>[Scrapy-1]</code>如何理解<code>yield</code>关键字</h2>

<p>﻿
为了理解什么是<code>yield</code>，你必须理解什么是生成器。在理解生成器之前，我们先来看看什么是迭代。</p>

<h4>可迭代对象 Iterables</h4>

<p>当你创建了一个列表，你可以逐项地读取它，这就叫做迭代：</p>

<pre><code>&gt;&gt;&gt; mylist = [1, 2, 3]
&gt;&gt;&gt; for i in mylist:
...     print i
...
1
2
3
</code></pre>

<p><code>mylist</code>是一个迭代对象，当你使用一个列表生成式来建立一个列表的时候，就建立了一个可迭代对象：</p>

<pre><code>&gt;&gt;&gt; mylist = [x*x for x in range(3)]
&gt;&gt;&gt; for i in mylist:
...     print i
...
0
1
4
</code></pre>

<p>所以你可以使用<code>for...in...</code>语法的对象都是可迭代对象：<code>lists, strings, files...</code></p>

<p>这些迭代对象你用起来很方便，因为你可以随时如你所愿地读取它们，但是这些对象数据都是存在内存中的，而当你的数据量非常大的时候，用这种方式去获取数据可能并不是你想要的了。</p>

<h4>生成器 Generators</h4>

<p>生成器是可以迭代的，但是<code>你只能迭代它们一次</code>，生成器并不把数据都放在内存中，它是实时地生成数据。</p>

<pre><code>&gt;&gt;&gt; mygenerator = (x*x for x in range(3))
&gt;&gt;&gt; for i in mygenerator:
...     print i
...
0
1
4
</code></pre>

<p>这和数组生成式是一样的除了<code>[]</code>和<code>()</code>的区别，由于生成器只能使用一次，所以你不能再次执行<code>for i in mygenerator</code>，先计算出0，再计算出1，然后一个接一个...</p>

<h4>Yield 关键字</h4>

<p><code>yield</code>是一个关键字，作用和<code>return</code>差不多，差别在<code>yield</code>返回的是一个生成器。</p>

<pre><code>&gt;&gt;&gt; def createGenerator():
...     mylist = range(3)
...     for i in mylist:
...         yield i*i
...
&gt;&gt;&gt; mygenerator = createGenerator()
&gt;&gt;&gt; print mygenerator
&lt;generator object createGenerator at 0x103c539b0&gt;
&gt;&gt;&gt; for i in mygenerator:
...     print i
...
0
1
4
</code></pre>

<p>这个例子可能没什么用，但是它让你知道，这个函数会返回一大批你只需要使用一次的数据。</p>

<p>为了深入理解<code>yield</code>，你必须理解：当你调用这个函数的时候，函数内部的生成器的代码并不立即执行，这个函数只是返回一个生成器对象。
那么你的生成器的代码什么时候执行呢？当你使用<code>for...in...</code>进行迭代的时候。</p>

<p>我来看看程序的执行情况：</p>

<pre><code>def createGenerator():
    mylist = range(3)
    print('aaaa')
    for i in mylist:
        print('bbbb')
        yield i*i

mygenerator = createGenerator()

for i in mygenerator:
    print(str(i))


aaaa
bbbb
0
bbbb
1
bbbb
4
</code></pre>

<p>第一次<code>for</code>循环的时候，函数会执行，当遇到<code>yield</code>的时候，返回第一个结果，后续的迭代会返回函数中定义的循环的下一次的<code>yield</code>结果。所以，怎么理解呢？
<strong><code>一个生成器对应的就是一个循环，每一次对生成器对象进行迭代，都是在执行这个循环</code></strong>
如果生成器内没有<code>yield</code>关键字，那么这个生成器被认为是空的。</p>

  </div>


</body>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115892756-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-115892756-1');
</script>


</html>